package org.tp;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import org.tp.*;


terminal SEMIC, COMMA, DOT, DDOT, COLON, LPAR, RPAR, LBRACE, RBRACE, LBRACKET, RBRACKET,
    IF, THEN, ELSE, WHILE, REPEAT, DO, FOR, IN, BOOLEAN,
    VAR, ARRAY, OF, LIST, SET, MAP, STRUCT, DQUOTE, RETURN,
    AFF, AND, OR, LT, GT, LE, GE, EQ, DIFF, PLUS, MINUS, MINUS_U, MULT, DIV,
    FUNCTION, PROCEDURE, INT, FLOAT, STRING, CHAR, VOID;

terminal String IDENTIFIER, INTEGER, FLOATING, STRINGEXP, CHAREXP, BOOL;

non terminal Type type;
non terminal AST program, expr, ident, expr_list, funcs, instr, instrs,
                 block, funcDef, range, list, globalDecs, globalDec, struct_decl, struct_decls,
                 definition, param, params, decl, decls, map_of, map_of_list, fheader, decls_opt;


precedence nonassoc ELSE;
precedence nonassoc IF;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MINUS_U;

program ::=
	globalDecs:gds funcs:fs {: RESULT = new Program(gds, fs); :}
	| funcs:f {: RESULT = new Program(null, f); :}
	;

globalDecs ::=
  globalDecs:gds globalDec:g {: RESULT = new GlobalDeclarations(gds, g); :}
  | globalDec:g {: RESULT = g; :}
  ;

globalDec ::=
  ident:i EQ definition:d {: RESULT = new GlobalDeclaration(i, d); :}
  ;

definition ::=
  expr:e SEMIC {: RESULT = e; :}
  | STRUCT LBRACE struct_decls:d RBRACE {: RESULT = d; :}
  ;

struct_decls ::=
  struct_decls:ds struct_decl:d {: RESULT = new VarStructDeclarations(d, ds); :}
  | struct_decl:d {: RESULT = d; :}
  ;

struct_decl ::=
  ident:id COLON type:t SEMIC
    {: RESULT = new VarStructDeclaration(id, null, t); :}
  ;

funcs ::=
  funcs:fs funcDef:f {: RESULT = new AST(f, fs, EnumTag.FUNCTIONS); :}
  | funcDef:f {: RESULT = f; :}
  ;

funcDef ::=
  fheader:h block:b {: 
    RESULT = new Function(h, b);
   :}
  | fheader:h SEMIC {:
    RESULT = new Function(h, null);
   :}
  ;

fheader ::=
  FUNCTION ident:i LPAR params:p RPAR COLON type:t
  {: RESULT = new Header(i, p, t); :}
  | PROCEDURE ident:i LPAR params:p RPAR
  {: RESULT = new Header(i, p); :}
  ;

block ::=
	LBRACE {:
			Env n = new Env(Main.currentEnv);
			System.out.println("Creating new environment 	" + n.getNum());
			if (Main.firstEnv == null) {
	      Main.firstEnv = Main.currentEnv = n;
			} else {
				Main.currentEnv.putNext(n);
				Main.currentEnv = n;
			}
		:} decls_opt:ds instrs:i RBRACE {:
			Main.currentEnv = Main.currentEnv.getPrev();
			System.out.println("Closing environment");
		  RESULT = new Block(ds, i);
		:}
	| instr:i
	  {: RESULT = i; :}
	;

params ::=
  params:ps COMMA param:p {: RESULT = new Parameters(p, ps); :}
  | param:p {: RESULT = p; :}
  ;

param ::=
  ident:id COLON type:t {: RESULT = new Parameter(id, null, t); :}
  //| VOID {: RESULT = new AST(null, null, EnumTag.PARAM); :}
  ;

decls_opt ::=
  decls_opt:dco decl:d
    {: RESULT = new OptDeclarations(d, dco); :}
  | 
    {: RESULT = new OptDeclarations(null, null); :}
  ;

decls ::=
	decls:ds decl:d {: RESULT = new VarDeclarations(d, ds); :}
	| decl:d {: RESULT = d; :}
	;

decl ::=
	ident:id COLON type:t SEMIC
		{: RESULT = new VarDeclaration(id, null, t); :}
	;

type ::=
	INT
		{: RESULT = new Type(EnumType.INT); :}
	| FLOAT
		{: RESULT = new Type(EnumType.FLOAT); :}
	| CHAR
		{: RESULT = new Type(EnumType.CHAR); :}
	| STRING
		{: RESULT = new Type(EnumType.STRING); :}
	| ARRAY LBRACKET INTEGER:i RBRACKET OF type:t
		{: RESULT = new Type(t, null, new Integer(i), EnumType.ARRAY); :}
	| LIST OF type:t
		{: RESULT = new Type(t, null, EnumType.LIST); :}
  | ident:i
    {: RESULT = new Type(EnumType.STRUCT, i.getName()); :}
	;

instrs ::= 
	instrs:i1 instr:i2
	  {: RESULT = new Instructions(i1, i2); :}
	| instr:i
	  {: RESULT = i; :}
	;

instr ::= 
  IF LPAR expr:e RPAR block:b1 ELSE block:b2
    {: RESULT = new If(e, new ThenElse(b1, b2)); :}
  | IF LPAR expr:e RPAR block:b
    {: RESULT = new If(e, new ThenElse(b, null)); :}
  | WHILE LPAR expr:e RPAR block:b
    {: RESULT = new Loop(e, b, EnumTag.WHILE); :}
  | REPEAT block:b WHILE expr:e
    {: RESULT = new AST(e, b, EnumTag.DOWHILE); :}
  | FOR ident:v IN range:r block:b
    {: RESULT = new Loop(new ForRange(v, r), b, EnumTag.FOR); :}
  | ident:v AFF expr:e SEMIC
    {: RESULT = new Affect(v, e); :}
  | RETURN expr:e SEMIC
    {: RESULT = new Return(e, null); :}
  ;

range ::=
  LBRACKET expr:e1 DDOT expr:e2 RBRACKET {: RESULT = new AST(e1, e2, EnumTag.RANGE); :}
  | LBRACKET list:l RBRACKET {: RESULT = l; :}
  | LBRACE list:l RBRACE {:RESULT = l; :}
  | ident:v {: RESULT = v; :}
  ;

list ::=  // use in list affectation and in function call
	list:l COMMA expr:e {: RESULT = new AST(l, e, EnumTag.LIST); :}
	| expr:e {: RESULT = e; :}
	;

expr_list ::=
  expr_list:e1 COMMA expr:e2 {: RESULT = new AST(e1, e2, EnumTag.EXPRLIST); :}
  | expr:e {: RESULT = e; :}
  ;

map_of ::=
  LBRACE map_of_list RBRACE
    {: RESULT = new AST(null, null); :}
  ;

map_of_list ::=
  map_of_list COMMA LPAR expr COMMA expr RPAR
    {: RESULT = new AST(null, null); :}
  | LPAR expr COMMA expr RPAR
    {: RESULT = new AST(null, null); :}
  ;

expr ::=
	expr:e1 AND expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.AND); :}                         // a && b
	| expr:e1 OR expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.OR); :}                         // a || b
	| expr:e1 LT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.LT); :}                         // a < b
	| expr:e1 GT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.GT); :}                         // a > b
	| expr:e1 LE expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.LE); :}                         // a <= b
	| expr:e1 GE expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.GE); :}                         // a >= b
	| expr:e1 EQ expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.EQ); :}                         // a = b
	| expr:e1 DIFF expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.DIFF); :}                     // a != b
	| expr:e1 PLUS expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.PLUS, e1.getType()); :}       // a + b
	| expr:e1 MINUS expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.MINUS); :}                   // a - b
	| expr:e1 MULT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.MULT); :}                     // a * b
	| expr:e1 DIV expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.DIV); :}                       // a / b
	| MINUS expr:e       {: RESULT = new AST(e, null, EnumTag.MINUS_U); :} %prec MINUS_U           // -a
  | ident:i LPAR list:l RPAR {: RESULT = new FunctionCall(i, l); :}                              // foo(a, b, c)
  | ident LBRACKET expr RBRACKET {: RESULT = new AST(null, null); :}                             // foo[a]
  | expr DOT ident {: RESULT = new AST(null, null); :}                                           // a.foo
	| INTEGER:i {: RESULT = new Variable(EnumTag.INTEGER, i, new Type(EnumType.INT)); :}           // 2
	| FLOATING:f {: RESULT = new Variable(EnumTag.FLOATING, f, new Type(EnumType.FLOAT)); :}       // 3.14
	| STRINGEXP:st {: RESULT = new Variable(EnumTag.STRING, st, new Type(EnumType.STRING)); :}     // "PI"
	| CHAREXP:ch {: RESULT = new Variable(EnumTag.CHAR, ch, new Type(EnumType.CHAR)); :}           // 'P'
  | LPAR expr:e RPAR {: RESULT = e; :}                                                           // (a)
  | ident:v {: RESULT = v; :}                                                                    // foo
	| BOOL:b {: RESULT = new Variable(EnumTag.BOOLEAN, b); :}                                      // 'True'
  | map_of {: RESULT = new AST(null, null); :}                                                   // {(a,b),(c,d)}
	;

ident ::=
	IDENTIFIER:id {: RESULT = new Variable(EnumTag.IDENT, id); :}
	;

