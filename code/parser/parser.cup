package org.tp;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;
import org.tp.*;


terminal SEMIC, COMMA, DOT, COLON, LPAR, RPAR, LBRACE, RBRACE, LBRACKET, RBRACKET,
    IF, THEN, ELSE, WHILE, REPEAT, DO, FOR, IN, 
    VAR, ARRAY, OF, LIST, SET, MAP, STRUCT,
    TRUE, FALSE, DQUOTE, RETURN,
    AFF, AND, OR, LT, GT, LE, GE, EQ, DIFF, PLUS, MINUS, MINUS_U, MULT, DIV,
    FUNCTION, PROCEDURE, INT, FLOAT, STRING, CHAR, VOID;

terminal String IDENTIFIER, INTEGER, FLOATING, STRINGEXP, CHAREXP, BOOLEAN;

non terminal Type type;
non terminal AST program, expr, ident, expr_list, funcs, instr, instrs,
                 block, funcDef, range, list, globalDecs, globalDec,
                 definition, param, params, decl, decls, map_of, map_of_list;


precedence right ELSE;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MINUS_U;

program ::=
	globalDecs:ds funcs:fs {: RESULT = new AST(ds, fs, EnumTag.PROGRAM); :}
	| funcs:f {: RESULT = f;:}
	;

globalDecs ::=
  globalDecs:gs globalDec:g {: RESULT = new AST(gs, g, EnumTag.GLOBAL_DECS); :}
  | globalDec:g {: RESULT = g; :}
  ;

globalDec ::=
  ident:i EQ definition:d {: RESULT = new AST(i, d, EnumTag.GLOBAL_DEC); :}
  ;

definition ::=
  expr:e SEMIC {: RESULT = e; :}
  | STRUCT LBRACE decls:d RBRACE {: RESULT = d; :}
  ;

funcs ::=
  funcs:fs funcDef:f {: RESULT = new AST(f, fs, EnumTag.FUNCTIONS); :}
  | funcDef:f {: RESULT = f; :}
  ;

funcDef ::=
  FUNCTION ident:i LPAR params:p RPAR COLON type:t block:b {: 
  	AST params = new AST(p, b, EnumTag.FUNCTION_CORE);
    RESULT = new AST(i, params, EnumTag.FUNCTION, t);
   :}
  | PROCEDURE ident:i LPAR params:p RPAR block:b {:
  	 AST params = new AST(p, b, EnumTag.FUNCTION_CORE);
     RESULT = new AST(i, params, EnumTag.PROCEDURE);
   :}
  ;

block ::=
	LBRACE decls:ds instrs:i {:
			Env n = new Env(Main.currentEnv);
			System.out.println("Creating new environment 	" + n.getNum());
			if (Main.firstEnv == null){
	      Main.firstEnv = Main.currentEnv = n;
			} else {
				Main.currentEnv.putNext(n);
				Main.currentEnv = n;
			}
		:}
	RBRACE
		{:
			Main.currentEnv = Main.currentEnv.getPrev();
			System.out.println("Closing environment");
		  RESULT = new AST(ds, i, EnumTag.BLOCK);
		:}
	| LBRACE instrs:i RBRACE
	  {: RESULT = i; :}
	| instr:i
	  {: RESULT = i; :}
	;

params ::=
  params:ps COMMA param:p {: RESULT = new AST(p, ps, EnumTag.PARAMS); :}
  | param:p {: RESULT = p; :}
  ;

param ::=
  ident:id COLON type:t {: RESULT = new AST(id, null, EnumTag.PARAM, t); :}
  //| VOID {: RESULT = new AST(null, null, EnumTag.PARAM); :}
  ;

decls ::=
	decls:ds decl:d {: RESULT = new AST(d, ds, EnumTag.DECSVAR); :}
	| decl:d {: RESULT = d; :}
	;

decl ::=
	ident:id COLON type:t SEMIC
		{: RESULT = new AST(id, null, EnumTag.DECVAR, t); :}
	;

type ::=
	INT
		{: RESULT = new Type(EnumType.INT); :}
	| FLOAT
		{: RESULT = new Type(EnumType.FLOAT); :}
	| CHAR
		{: RESULT = new Type(EnumType.CHAR); :}
	| STRING
		{: RESULT = new Type(EnumType.STRING); :}
	| ARRAY LBRACKET INTEGER:i RBRACKET OF type:t
		{: RESULT = new Type(t, null, new Integer(i), EnumType.ARRAY); :}
	| LIST OF type:t
		{: RESULT = new Type(t, null, EnumType.LIST); :}
	;

instr ::= 
	IF LPAR expr:e RPAR block:b1 ELSE block:b2
	  {: RESULT = new AST(e, new AST(b1, b2, EnumTag.THENELSE), EnumTag.IF); :}
  | WHILE LPAR expr:e RPAR block:b
    {: RESULT = new AST(e, b, EnumTag.WHILE); :}
  | REPEAT block:b WHILE expr:e
    {: RESULT = new AST(e, b, EnumTag.DOWHILE); :}
	| FOR ident:v IN range:r block:b
      {: RESULT = new AST(new AST(v, r, EnumTag.FOR_RANGE), b, EnumTag.FOR); :}
	| IF LPAR expr:e RPAR block:b
	  {: RESULT = new AST(e, new AST(b, null, EnumTag.THENELSE), EnumTag.IF); :}
	| ident:v AFF expr:e SEMIC
	  {: RESULT = new AST(v, e, EnumTag.AFF); :}
	| RETURN expr:e SEMIC
	  {: RESULT = new AST(e, null, EnumTag.RETURN); :}
	;

range ::=
  LBRACKET expr:e1 DOT DOT expr:e2 RBRACKET {: RESULT = new AST(e1, e2, EnumTag.RANGE); :}
  | LBRACKET list:l RBRACKET {: RESULT = l; :}
  | LBRACE list:l RBRACE {:RESULT = l; :}
  | ident:v {: RESULT = v; :}
  ;

list ::=
	list:l COMMA expr:e {: RESULT = new AST(l, e, EnumTag.LIST); :}
	| expr:e {: RESULT = e; :}
	;

instrs ::= 
	instrs:i1 instr:i2
	  {: RESULT = new AST(i1, i2, EnumTag.SUCC); :}
	| instr:i
	  {: RESULT = i; :}
	;

expr_list ::=
  expr_list:e1 COMMA expr:e2 {: RESULT = new AST(e1, e2, EnumTag.EXPRLIST); :}
  | expr:e {: RESULT = e; :}
  ;

map_of ::=
  LBRACE map_of_list RBRACE {: :}
  ;

map_of_list ::=
  map_of_list COMMA LPAR INTEGER COMMA IDENTIFIER RPAR {: :}
  | LPAR INTEGER COMMA IDENTIFIER RPAR {: :}
  ;

expr ::=
	expr:e1 AND expr:e2 {: RESULT = new AST(e1, e2, EnumTag.AND); :} 
	| expr:e1 OR expr:e2 {: RESULT = new AST(e1, e2, EnumTag.OR); :} 
	| expr:e1 LT expr:e2 {: RESULT = new AST(e1, e2, EnumTag.LT); :} 
	| expr:e1 GT expr:e2 {: RESULT = new AST(e1, e2, EnumTag.GT); :} 
	| expr:e1 LE expr:e2 {: RESULT = new AST(e1, e2, EnumTag.LE); :} 
	| expr:e1 GE expr:e2 {: RESULT = new AST(e1, e2, EnumTag.GE); :} 
	| expr:e1 EQ expr:e2 {: RESULT = new AST(e1, e2, EnumTag.EQ); :} 
	| expr:e1 DIFF expr:e2 {: RESULT = new AST(e1, e2, EnumTag.DIFF); :}
	| expr:e1 PLUS expr:e2 {: RESULT = new AST(e1, e2, EnumTag.PLUS, e1.getType()); :} 
	| expr:e1 MINUS expr:e2 {: RESULT = new AST(e1, e2, EnumTag.MINUS); :} 
	| expr:e1 MULT expr:e2 {: RESULT = new AST(e1, e2, EnumTag.MULT); :} 
	| expr:e1 DIV expr:e2 {: RESULT = new AST(e1, e2, EnumTag.DIV); :} 
	| MINUS expr:e {: RESULT = new AST(e, null, EnumTag.MINUS_U); :} %prec MINUS_U 
	| LPAR expr:e RPAR {: RESULT = e; :}
	| INTEGER:it {:
      RESULT = new AST(EnumTag.INTEGER, it, new Type(EnumType.INT)); 
		:}
	| FLOATING:f {:
      RESULT = new AST(EnumTag.FLOATING, f, new Type(EnumType.FLOAT));
		:}
	| STRINGEXP:st {:
      RESULT = new AST(EnumTag.STRING, st, new Type(EnumType.STRING));  
		:}
	| CHAREXP:ch {:
      RESULT = new AST(EnumTag.CHAR, ch, new Type(EnumType.CHAR));
	  :}
	| BOOLEAN:b {:
      RESULT = new AST(EnumTag.BOOLEAN, b);
	  :}
	| ident:v {: RESULT = v; :}
  | map_of {: :}
	;

ident ::=
	IDENTIFIER:id {: RESULT = new AST(EnumTag.VAR, id); :}
	;

