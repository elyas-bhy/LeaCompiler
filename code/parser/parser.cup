package org.gen;
 
import java_cup.runtime.*;
import java.io.*;
import java.lang.*;


terminal SEMIC, COMMA, DOT, DDOT, COLON, LPAR, RPAR, LBRACE, RBRACE, LBRACKET, RBRACKET,
    IF, THEN, ELSE, WHILE, REPEAT, DO, FOR, IN, BOOLEAN,
    VAR, ARRAY, OF, EXPRLIST, SET, MAP, STRUCT, DQUOTE, RETURN,
    AFF, AND, OR, LT, GT, LE, GE, EQ, DIFF, PLUS, MINUS, MINUS_U, MULT, DIV,
    FUNCTION, PROCEDURE, INT, FLOAT, STRING, CHAR, VOID;

terminal String IDENTIFIER, INTEGER, FLOATING, STRINGEXP, CHAREXP, BOOL;

non terminal Type type;
non terminal AST program, expr, ident, funcs, instr, instrs, list_rec, identFields,
                 block, funcDef, range, list, globalDecs, globalDec, struct_decl, struct_decls,
                 definition, parameters, param_list, param, decl, map_of, map_of_list,
                 fheader, decls_opt;


precedence nonassoc ELSE;
precedence nonassoc IF;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MINUS_U;

program ::=
	globalDecs:gds funcs:fs {: RESULT = new Program(gds, fs); :}
	| funcs:f {: RESULT = new Program(null, f); :}
	;

globalDecs ::=
  globalDecs:gds globalDec:g {: RESULT = new GlobalDeclarations(gds, g); :}
  | globalDec:g {: RESULT = g; :}
  ;

globalDec ::=
  ident:i EQ definition:d {: RESULT = new GlobalDeclaration(i, d); :}
  ;

definition ::=
  expr:e SEMIC {: RESULT = e; :}
  | STRUCT LBRACE struct_decls:d RBRACE {: RESULT = d; :}
  ;

struct_decls ::=
  struct_decls:ds struct_decl:d {: RESULT = new VarStructDeclarations(d, ds); :}
  | struct_decl:d {: RESULT = d; :}
  ;

struct_decl ::=
  ident:id COLON type:t SEMIC
    {: RESULT = new VarStructDeclaration(id, null, t); :}
  ;

funcs ::=
  funcs:fs funcDef:f {: RESULT = new Functions(f, fs); :}
  | funcDef:f {: RESULT = f; :}
  ;

funcDef ::=
  fheader:h block:b 
    {: RESULT = new Function(h, b); :}
  | fheader:h SEMIC
    {: RESULT = new Function(h, null); :}
  ;

fheader ::=
  FUNCTION ident:i LPAR parameters:p RPAR COLON type:t
    {: RESULT = new Header(i, p, t); :}
  | PROCEDURE ident:i LPAR parameters:p RPAR
    {: RESULT = new Header(i, p); :}
  ;

block ::=
	LBRACE {:
			Env n = new Env(Main.currentEnv);

			if (Main.DEBUG) System.out.println("Creating new environment 	" + n.getNum());
			if (Main.firstEnv == null) {
        Main.firstEnv = Main.currentEnv = n;
			} else {
        Main.currentEnv.putNext(n);
        Main.currentEnv = n;
			}
    :} decls_opt:ds instrs:i RBRACE {:
      if (Main.currentEnv.getPrev() == null) {
        Main.globalEnv.putNext(Main.currentEnv);
        Main.firstEnv = null;
      }
			Main.currentEnv = Main.currentEnv.getPrev();
			if (Main.DEBUG) System.out.println("Closing environment");
		  RESULT = new Block(ds, i);
		:}
	| instr:i
	  {: RESULT = i; :}
	;

parameters ::=
  param_list:pl {: RESULT = pl; :}
  | {: RESULT = new Parameters(null, null); :}
  ;

param_list ::=
  param_list:ps COMMA param:p {: RESULT = new Parameters(p, ps); :}
  | param:p {: RESULT = p; :}
  ;

param ::=
  ident:id COLON type:t {: RESULT = new Parameter(id, null, t); :}
  ;

decls_opt ::=
  decls_opt:dco decl:d
    {: RESULT = new OptDeclarations(d, dco); :}
  | 
    {: RESULT = new OptDeclarations(null, null); :}
  ;

decl ::=
	ident:id COLON type:t SEMIC
		{: RESULT = new VarDeclaration(id, null, t); :}
	;

type ::=
	INT
		{: RESULT = new Type(EnumType.INT); :}
	| FLOAT
		{: RESULT = new Type(EnumType.FLOAT); :}
	| CHAR
		{: RESULT = new Type(EnumType.CHAR); :}
	| STRING
		{: RESULT = new Type(EnumType.STRING); :}
  | BOOLEAN
    {: RESULT = new Type(EnumType.BOOLEAN); :}
	| ARRAY LBRACKET INTEGER:i RBRACKET OF type:t
		{: RESULT = new Type(t, null, new Integer(i), EnumType.ARRAY); :}
	| EXPRLIST OF type:t
		{: RESULT = new Type(t, null, EnumType.EXPRLIST); :}
  | ident:i
    {: RESULT = new Type(EnumType.STRUCT, i.getName()); :}
	;

instrs ::= 
	instrs:i1 instr:i2
	  {: RESULT = new Instructions(i1, i2); :}
	| instr:i
	  {: RESULT = i; :}
	;

instr ::= 
  IF LPAR expr:e RPAR block:b1 ELSE block:b2
    {: RESULT = new If(e, new ThenElse(b1, b2)); :}
  | IF LPAR expr:e RPAR block:b
    {: RESULT = new If(e, new ThenElse(b, null)); :}
  | WHILE LPAR expr:e RPAR block:b
    {: RESULT = new Loop(e, b, EnumTag.WHILE); :}
  | REPEAT block:b WHILE LPAR expr:e RPAR SEMIC
    {: RESULT = new DoWhile(e, b); :}
  | FOR ident:v IN range:r block:b
    {: RESULT = new Loop(new ForRange(v, r), b, EnumTag.FOR); :}
  | identFields:v AFF expr:e SEMIC
    {: RESULT = new Affect(v, e); :}
  | RETURN expr:e SEMIC
    {: RESULT = new Return(e, null); :}
  | identFields:i LPAR list:l RPAR SEMIC
    {: RESULT = new ProcedureCall(i, l); :}  
  ;

range ::=
  LBRACKET expr:e1 DDOT expr:e2 RBRACKET {: RESULT = new AST(e1, e2, EnumTag.RANGE); :}
  | LBRACKET list:l RBRACKET {: RESULT = l; :}
  | LBRACE list:l RBRACE {:RESULT = l; :}
  | identFields:id {: RESULT = id; :}
  ;

list ::=  // used in list affectation and in function call
  list_rec:l {: RESULT = l; :}
  | {: RESULT = new ExprList(null, null); :}
  ;

list_rec ::=
  list_rec:l COMMA expr:e {: RESULT = new ExprList(l, e); :}
  | expr:e {: RESULT = e; :}
  ;

map_of ::=
  LBRACE map_of_list RBRACE
    {: RESULT = new AST(null, null); :}
  ;

map_of_list ::=
  map_of_list COMMA LPAR expr COMMA expr RPAR
    {: RESULT = new AST(null, null); :}
  | LPAR expr COMMA expr RPAR
    {: RESULT = new AST(null, null); :}
  ;

expr ::=
	expr:e1 AND expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.AND); :}                         // a && b
	| expr:e1 OR expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.OR); :}                         // a || b
	| expr:e1 LT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.LT); :}                         // a < b
	| expr:e1 GT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.GT); :}                         // a > b
	| expr:e1 LE expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.LE); :}                         // a <= b
	| expr:e1 GE expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.GE); :}                         // a >= b
	| expr:e1 EQ expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.EQ); :}                         // a = b
	| expr:e1 DIFF expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.DIFF); :}                     // a != b
	| expr:e1 PLUS expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.PLUS, e1.getType()); :}       // a + b
	| expr:e1 MINUS expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.MINUS); :}                   // a - b
	| expr:e1 MULT expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.MULT); :}                     // a * b
	| expr:e1 DIV expr:e2 {: RESULT = new Operation(e1, e2, EnumTag.DIV); :}                       // a / b
	| MINUS expr:e       {: RESULT = new Operation(null, e, EnumTag.MINUS_U); :} %prec MINUS_U           // -a
  | identFields:i LPAR list:l RPAR {: RESULT = new FunctionCall(i, l); :}                        // foo(a, b, c)
  | identFields LBRACKET expr RBRACKET {: RESULT = new AST(null, null); :}                       // foo[a]
  | INTEGER:i {: RESULT = new Variable(EnumTag.INTEGER, i, new Type(EnumType.INT)); :}           // 2
  | FLOATING:f {: RESULT = new Variable(EnumTag.FLOATING, f, new Type(EnumType.FLOAT)); :}       // 3.14
  | STRINGEXP:st {: RESULT = new Variable(EnumTag.STRING, st, new Type(EnumType.STRING)); :}     // "PI"
  | CHAREXP:ch {: RESULT = new Variable(EnumTag.CHAR, ch, new Type(EnumType.CHAR)); :}           // 'P'
  | LPAR expr:e RPAR {: RESULT = e; :}                                                           // (a)
  | identFields:id {: RESULT = id; :}                                                            // a.b.foo
	| BOOL:b {: RESULT = new Variable(EnumTag.BOOLEAN, b); :}                                      // 'True'
  | map_of {: RESULT = new AST(null, null); :}                                                   // {(a,b),(c,d)}
	;

ident ::=
	IDENTIFIER:id {: RESULT = new Variable(EnumTag.IDENT, id); :}
	;

identFields ::=
  identFields:idfs DOT ident:id {: RESULT = new FieldAccess(id, idfs); :}
  | ident:id {: RESULT = id; :}
  ;
